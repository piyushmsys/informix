## Protocol Buffer

### Overview
    Protocol Buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data.

> It is like we define the data format to be transmitted and then code for the respective language can be generated. It supports a huge list of programming languages like C++, Java, Rails, C# etc
    
### How does proto buffer look like
```proto
message Person {
  optional string name = 1;
  optional int32 id = 2;
  optional string email = 3;
}
```
    In the above proto buffer definition, we are trying to convey the protocol buffer that we will be transmitting a 
    person object which may have name,id and email as fields and proto compiler will use this definition to 
    generate language specific code.

### What Problems do Protocol Buffers Solve?
* **Efficiency:** Due to its compact size it does not take much network bandwidth and data transmission becomes quick and easy which gradually enhances the efficiency.
* **Interoperability:** Protobuf supports multiple programming languages, allowing data to be serialized and deserialized in one language and then transmitted and processed in another. This interoperability simplifies communication between systems written in different languages
* **Schema Evolution / Easy to enhance:** Protobuf messages are defined using a schema, which specifies the structure and data types of the serialized data. This schema can evolve without breaking compatibility with existing clients or servers.
* **Versioning or Backward and Forward Compatibility:** This means that clients and servers using different versions of the schema can still communicate with each other without requiring immediate updates. As long as both parties adhere to certain compatibility rules, they can exchange messages safely.
* **Code Generation:** Protobuf compilers generate code for serializing and deserializing messages in different programming languages based on the schema definition. This generated code handles the low-level encoding and decoding details, allowing developers to focus on application logic rather than serialization concerns.

## In what situations are Protocol Buffers not suitable?
* **Can not compare untill fully parsed:** When protocol buffers are serialized, the same data can have many different binary serializations. You cannot compare two messages for equality without fully parsing them.
* **Can not handle very large messages:** Protocol buffers tend to assume that entire messages can be loaded into memory at once and are not larger than an object graph. For data that exceeds a few megabytes, consider a different solution; when working with larger data, you may effectively end up with several copies of the data due to serialized copies, which can cause surprising spikes in memory usage.
* **Less readable:** Protocol buffer messages don’t inherently self-describe their data, but they have a fully reflective schema that you can use to implement self-description. That is, you cannot fully interpret one without access to its corresponding ```.proto``` file 

## How do Protocol Buffers Work? 
>The following diagram shows how you use protocol buffers to work with your data.

![Protocol Buffers](/images/protocol-buffers-concepts.png)

    The code generated by protocol buffers provides utility methods to retrieve data from files and streams, extract individual 
    values from the data, check if data exists, serialize data back to a file or stream, and other useful functions.

## Sample code
### Proto definition
```proto
    message Person {
        optional string name = 1;
        optional int32 id = 2;
        optional string email = 3;
    }
```

### Builder class generated by proto compiler
```java
Person john = Person.newBuilder()
    .setId(1234)
    .setName("John Doe")
    .setEmail("jdoe@example.com")
    .build();

```

### Code like below can be used to serialize the above message
```java
output = new FileOutputStream(args[0]);
john.writeTo(output);
```

### The same message can be deserialized like below in other languages like C++
```c++
Person john;
fstream input(argv[1], ios::in | ios::binary);
john.ParseFromIstream(&input);
int id = john.id();
std::string name = john.name();
std::string email = john.email();
```

## Protocol Buffers Definition Syntax 
> proto2 and proto3 has bit different syntax definitions. Please refer below links to check it in detail.
* [Proto2](https://protobuf.dev/programming-guides/proto2/)
* [Proto3](https://protobuf.dev/programming-guides/proto3/)

### Message syntax of proto2 and proto3
#### Proto 2
```proto
syntax = "proto2";

message SearchRequest {
  optional string query = 1;
  optional int32 page_number = 2;
  optional int32 results_per_page = 3;
}
```

#### Proto 3
```proto
syntax = "proto3";

message SearchRequest {
  string query = 1;
  int32 page_number = 2;
  int32 results_per_page = 3;
}
```

> **Note :** It is mandatory to use ```syntax = "proto3";``` as first not empty line in ```proto3``` message otherwise proto compiler will treat it as ```proto2``` message.

### Defining A Message Type

#### **Message level restrictions**
**Example** 
```
syntax = "proto3";

message SearchRequest {
  string query = 1;
  int32 page_number = 2;
  int32 results_per_page = 3;
}
```
* The first line of the file specifies that you’re using proto3 syntax: if you don’t do this the protocol buffer compiler will assume you are using proto2. 
* The SearchRequest message definition specifies three fields (name/value pairs), one for each piece of data that you want to include in this type of message. Each field has a name and a type

#### Defining field types
**Available data types**
* [Scaler Value type](https://protobuf.dev/programming-guides/proto3/#scalar)
* [Enumerations](https://protobuf.dev/programming-guides/proto3/#enum)

#### Specifying Field numbers
* The given number must be unique among all fields for that message.
* Field numbers 19,000 to 19,999 are reserved for the Protocol Buffers implementation. The protocol buffer compiler will complain if you use one of these reserved field numbers in your message.
* You cannot use any previously reserved field numbers or any field numbers that have been allocated to extensions.

#### Specifying Field Labels 
* ```optional:``` An optional field is in one of two possible states:
    - the field is set, and contains a value that was explicitly set or parsed from the wire. It will be serialized to the wire.
    - the field is unset, and will return the default value. It will not be serialized to the wire.
* ```repeated:``` this field type can be repeated zero or more times in a well-formed message. The order of the repeated values will be preserved.
* ```map:``` this is a paired key/value field type. See [Maps](https://protobuf.dev/programming-guides/encoding/#maps) for more on this field type.
    

### Compile and generate code using proto file
* Download the protobuffer compiler from [here](https://github.com/protocolbuffers/protobuf/releases/tag/v26.0)
* Extract and look for protoc.exe(for unix and mac file extension would be different)
* Create a sample proto like below and name it as ```developer.proto```
```proto
syntax = "proto3";

package com.msys;

option java_package = "com.msys.protobuf";

message Developer {
  optional string name = 1;
  optional int32 id = 2;
  optional string email = 3;
}
```
> I have created it with minimal configuration to test it. The same can be created with lot more configuration based on the requirement.
* Use the below command to compile and generate class file \
```protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/developer.proto```
> Replace ```$SRC_DIR``` with respective source directory and ```$DST_DIR``` with respective destination diretory.


Note: Explanation about proto syntax and more details will be added as part of [gRPC](gRpc.md) documentation


## References
* [https://protobuf.dev/](https://protobuf.dev/)
* [Proto 2 Tutorial](https://protobuf.dev/programming-guides/proto2/)
* [Proto 3 Tutorial](https://protobuf.dev/programming-guides/proto3/)
* [Proto Best Practise](https://protobuf.dev/programming-guides/dos-donts/)
* [Proto buffer Java tutorial](https://protobuf.dev/getting-started/javatutorial/)
* [Proto buffer Java Ref guide](https://protobuf.dev/reference/java/)
